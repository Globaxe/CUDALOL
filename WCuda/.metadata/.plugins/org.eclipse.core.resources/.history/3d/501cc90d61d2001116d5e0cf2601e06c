#include <iostream>

#include "cublas_v2.h"
#include "cudaTools.h"
#include "tab1DTools.h"

using std::cout;
using std::endl;

/*----------------------------------------------------------------------*\
 |*			Declaration 					*|
 \*---------------------------------------------------------------------*/

/*--------------------------------------*\
 |*		Public			*|
 \*-------------------------------------*/

bool isCublas_Ok(void);

/*--------------------------------------*\
 |*		Private			*|
 \*-------------------------------------*/

static bool isCublasBad_Ok(void);
static bool isCublasBest_Ok(void);

float* cublasBad(float* ptrA, float* ptrB, int m, int n, int k);
float* cublasBest(float* ptrA, float* ptrB, int m, int n, int k);

float* matrixMultBad(float* ptrDevA, float* ptrDevB, float* ptrDevC, int m, int n, int k);
float* matrixMultBest(float* ptrDevA, float* ptrDevB, float* ptrDevC, int m, int n, int k);

/**
 * i in [1,n]
 * j in [1,m]
 * s in [0, (n*m)-1]
 */
static unsigned int indice1D(int i, int j, int m);
static float* createA(int m, int k); // mxk
static float* createB(int k, int n); // kxn
static void fillTab(float* ptrTab, int n, int m);
static float* transpose(float* ptrTab, int n, int m);
static void afficher(float* ptrTab, int n, int m);
static void afficher(float* ptrTab, int size);

/*----------------------------------------------------------------------*\
 |*			Implementation 					*|
 \*---------------------------------------------------------------------*/

/*--------------------------------------*\
 |*		Public			*|
 \*-------------------------------------*/

/**
 *
 * Goal :
 *
 * 	AxB = C
 *
 * Rappel :
 *
 *  	(R1) C=(AB) ssi C'=(AB)'=B'A'
 *  	(R2) Cublas travail en Colomn Major (CM)!
 *	(R3) C tracail en Row Major (RW)!
 *	(R4) 	C_RM'=C_CM
 *		C_CM'=C_RM
 * Notons :
 *
 *  	(N1) RM : Row major
 *  	(N2) CM : Colomn major
 *
 * A mxk = 3x2
 * 	1 2
 * 	3 4
 * 	5 6
 *
 *      RM 1 2 3 4 5 6
 *	CM 1 3 5 2 4 6
 *
 * B kxn = 2x4
 * 	1 2 3 4
 * 	5 6 7 8
 *
 *      RM 1 2 3 4 5 6 7 8
 *	CM 1 5 2 6 3 7 4 8
 *
 * C mxn = 3x4
 * 	11 14 17 20
 * 	23 30 37 44
 * 	35 46 57 68
 *
 * 	RM : 11 14 17 20 23 30 37 44 35 46 57 68
 * 	CM : 11 23 35 14 30 46 17 37 57 20 44 68
 *
 * C' nxm 4x3
 * 	11 23 35
 * 	14 30 46
 * 	17 37 57
 * 	20 44 68
 *
 * 	RM : 11 23 35 14 30 46 17 37 57 20 44 68
 *	CM : 11 14 17 20 23 30 37 44 35 46 57 68
 *
 * Observation
 *
 * 	C en RM <=> C' en CM
 * 	C en CM <=> C' en RM
 */
bool isCublas_Ok(void)
    {
    cout << endl << "[Cublas : produit : cublasSgemm]" << endl;

    return isCublasBad_Ok() && isCublasBest_Ok();
    }

/*--------------------------------------*\
 |*		Private			*|
 \*-------------------------------------*/

bool isCublasBad_Ok(void)
    {
    const int m = 3;
    const int n = 4;
    const int k = 2;

    float* ptrA = createA(m, k);
    float* ptrB = createB(k, n);
    float ptrC_Theorique[m * n] =
	{
	11, 14, 17, 20, 23, 30, 37, 44, 35, 46, 57, 68
	}; //  C mxn

    float* ptrC = cublasBad(ptrA, ptrB, m, n, k);
    bool isOk = isEgale(ptrC, ptrC_Theorique, n * m);

//    afficher(ptrA, m, k);
//    afficher(ptrB, k, n);
//    afficher(ptrC, n, m);
//    afficher(ptrC_Theorique, n, m);

    delete[] ptrA;
    delete[] ptrB;
    delete[] ptrC;

    return isOk;
    }

bool isCublasBest_Ok(void)
    {
    const int m = 3;
    const int n = 4;
    const int k = 2;

    float* ptrA = createA(m, k);
    float* ptrB = createB(k, n);
    float ptrC_Theorique[m * n] =
	{
	11, 14, 17, 20, 23, 30, 37, 44, 35, 46, 57, 68
	}; //  C mxn

    float* ptrC = cublasBest(ptrA, ptrB, m, n, k);
    bool isOk = isEgale(ptrC, ptrC_Theorique, n * m);

//       afficher(ptrA, m, k);
//       afficher(ptrB, k, n);
//       afficher(ptrC, n, m);
//       afficher(ptrC_Theorique, n, m);

    delete[] ptrA;
    delete[] ptrB;
    delete[] ptrC;

    return isOk;
    }

float* cublasBad(float* ptrA, float* ptrB, int m, int n, int k)
    {
    //Allocations Cuda
    size_t sizeA = m * n * sizeof(float); // A mxk
    size_t sizeB = k * n * sizeof(float); // B kxn
    size_t sizeC = m * n * sizeof(float); // C mxn

    float* ptrDevA = NULL;
    float* ptrDevB = NULL;
    float* ptrDevC = NULL;

    HANDLE_ERROR(cudaMalloc((void**) &ptrDevA, sizeA));
    HANDLE_ERROR(cudaMalloc((void**) &ptrDevB, sizeB));
    HANDLE_ERROR(cudaMalloc((void**) &ptrDevC, sizeC));

    //Host->Device Matrice
    HANDLE_ERROR(cudaMemcpy(ptrDevA, ptrA, sizeA, cudaMemcpyHostToDevice));
    HANDLE_ERROR(cudaMemcpy(ptrDevB, ptrB, sizeB, cudaMemcpyHostToDevice));

    //initialisation de la matrice C de sortie
    HANDLE_ERROR(cudaMemset(ptrDevC, 0, sizeC));

    float* ptrC = matrixMultBad(ptrDevA, ptrDevB, ptrDevC, m, n, k);

    HANDLE_ERROR(cudaFree(ptrDevA));
    HANDLE_ERROR(cudaFree(ptrDevB));
    HANDLE_ERROR(cudaFree(ptrDevC));

    return ptrC;
    }

float* cublasBest(float* ptrA, float* ptrB, int m, int n, int k)
    {
    //Allocations Cuda
    size_t sizeA = m * n * sizeof(float); // A mxk
    size_t sizeB = k * n * sizeof(float); // B kxn
    size_t sizeC = m * n * sizeof(float); // C mxn

    float* ptrDevA = NULL;
    float* ptrDevB = NULL;
    float* ptrDevC = NULL;

    HANDLE_ERROR(cudaMalloc((void**) &ptrDevA, sizeA));
    HANDLE_ERROR(cudaMalloc((void**) &ptrDevB, sizeB));
    HANDLE_ERROR(cudaMalloc((void**) &ptrDevC, sizeC));

    //Host->Device Matrice
    HANDLE_ERROR(cudaMemcpy(ptrDevA, ptrA, sizeA, cudaMemcpyHostToDevice));
    HANDLE_ERROR(cudaMemcpy(ptrDevB, ptrB, sizeB, cudaMemcpyHostToDevice));

    //initialisation de la matrice C de sortie
    HANDLE_ERROR(cudaMemset(ptrDevC, 0, sizeC));

    float* ptrC = matrixMultBest(ptrDevA, ptrDevB, ptrDevC, m, n, k);

    HANDLE_ERROR(cudaFree(ptrDevA));
    HANDLE_ERROR(cudaFree(ptrDevB));
    HANDLE_ERROR(cudaFree(ptrDevC));

    return ptrC;
    }

/**
 * Inputs:
 *
 * 	A en RM
 * 	B en RM
 *
 * Outputs
 *
 * 	C en RM
 *
 * Objectifs :
 *
 * 	C= AxB
 *
 * Attention :
 *
 * 	Cublas travail en CM pour les inputs comme outputs
 *
 * Solutions :
 *
 * 	Notons f la fonction produit matriciuelle en Blas
 *
 * 		"matrice=f(matrice, matrice)"
 *
 * 	. On doit lui donner à manger A_CM et B_CM. En sortie on obtient C_CM !!
 *
 * 		C_CM=f(A_RM',B_RM')
 * 		C_RM=C_CM'
 *
 * 	TIP :
 *
 * 		En Blas, on peut choisir si l'on souhaite appliquer un operateur au matrice input.
 * 		Parmis ces opérateurs, on peut prendre l'operateur de transposer
 *
 * 			CUBLAS_OP_T
 *
 * 		Cet oprerateur nous evite de transposer nos matrices A_RM et B_RM en input! (GRATUIT)
 * 		Par contre en sortie on doit bien faire soi-meme la transposer! (PAYANT)
 */
float* matrixMultBad(float* ptrDevA, float* ptrDevB, float* ptrDevC, int m, int n, int k)
    {
    // Blas : apha A B + beta
    float alpha = 1;
    float beta = 0;

    int ligneA = m;
    int colonneB = n;
    int colonneA = k;

    int ldA = colonneA; // =#colonne A avec A mxk
    int ldB = colonneB; // =#colonne B avec B kxn
    int ldC = m; 	// =#colonne C avec C mxn : Attention m car en sortie C_CM. Comme C_CM=C_RM' alors n devient m et m devient n

    // Cublas : // C_CM=A_RM'*B_RM'
    cublasHandle_t handle;
    HANDLE_ERROR(cublasCreate(&handle));
    HANDLE_ERROR(cublasSgemm(handle, CUBLAS_OP_T, CUBLAS_OP_T, ligneA, colonneB, colonneA, &alpha, ptrDevA, ldA, ptrDevB, ldB, &beta, ptrDevC, ldC));
    //	CUBLAS_OP_T => transposer
    HANDLE_ERROR(cublasDestroy(handle));

    // Recuperation Resultat en CM
    int dim = n * m; // C_CM nxm
    size_t sizeC = dim * sizeof(float);
    float* ptrC_CM = new float[dim];
    HANDLE_ERROR(cudaMemcpy(ptrC_CM, ptrDevC, sizeC, cudaMemcpyDeviceToHost));

    // En sortie de cublas, on à C en CM ! Verifions
    // afficher(ptrC_CM, n * m);
    // afficher(ptrC_CM, n, m);

    // Pour avoir C en RM, on transpose le résultat
    float* ptrC_RM = transpose(ptrC_CM, n, m); // Resultat juste
    // afficher(ptrC_RM, m * n);
    // afficher(ptrC_RM, m, n);

    delete[] ptrC_CM;

    return ptrC_RM;
    }

/**
 * Objectifs :
 * 	C= AxB, A,B et C sont stocker en rowMajor sans utilisé l'opérateur de transposé !
 * Problème :
 * 	Cublas travail en Colomn Major !
 * Solutions :
 * 	Une conversion row Major - colomn Major est équivalent à l'opérateur transposé !
 *
 * 	Au lieux de calculé C=AxB on calcul C=BxA sans utilisé d'opérateur de transposé !
 * 	Ce qui donne au final C'=B'xA' en CM qui est égal à C en RM !
 */

/**
 * Inputs:
 *
 * 	A en RM
 * 	B en RM
 *
 * Outputs
 *
 * 	C en RM
 *
 * Objectifs :
 *
 * 	C= AxB
 *
 * Attention :
 *
 * 	Cublas travail en CM pour les inputs comme outputs
 *
 * Solutions :
 *
 *	On a
 *		A_RM
 *		B_RM
 *
 *	L'astuce est d'ici de calculer
 *
 *		f(B_RM,A_RM)
 *
 *	sans faire la moindre transposer! Mais on a inverser l'ordre!
 *	Qu'obtient on?
 *
 *		C_CM=B_RM*A_RM
 *		C_CM=B_CM'*A_CM' = (A_CM*BCM)'
 *
 *		Finalement
 *
 *		C_CM=f(B_RM,A_RM)
 *		C_RM=C_CM'=A_CM*BCM
 *
 *	On calcu B*A sans operateur transposer , ce qui equivaut é fare
 *
 *		B'*A'
 *
 *		qui est egale à
 *
 *		(AB)'
 *
 *
 *
 */
float* matrixMultBest(float* ptrDevA, float* ptrDevB, float* ptrDevC, int m, int n, int k)
    {
    // Blas
    int ligneU = n; //U=B_CM = B_RM' avec B kxn
    int colonneV = m; // V=A_RM = A_CM' avec A mxk
    int colonneU = k; //U=B_CM = B_RM' avec B kxn


    int ldU = colonneU; // =#colonne A avec A mxk
    int ldV = colonneV; // =#colonne B avec B kxn
    int ldW = n; 	// =#colonne C avec C mxn

    // Cublas : W=U*V
    cublasHandle_t handle;
    HANDLE_ERROR(cublasCreate(&handle));
    HANDLE_ERROR(cublasSgemm(handle, CUBLAS_OP_T, CUBLAS_OP_T, ligneU, colonneV, colonneU, &alpha, ptrDevA, ldU, ptrDevB, ldV, &beta, ptrDevC, ldW));
    //	CUBLAS_OP_T => transposer

    // Recuperation Resultat en CM
    int dim = n * m; // CPrime_CM nxm
    size_t sizeC = dim * sizeof(float);
    float* ptrCPrime_CM = new float[dim];
    HANDLE_ERROR(cudaMemcpy(ptrCPrime_CM, ptrDevC, sizeC, cudaMemcpyDeviceToHost));

    // En sortie de cublas, on à C' en CM donc C en RM Verifions
    float* ptrC_RM = ptrCPrime_CM;

    afficher(ptrC_RM, m * n);
    afficher(ptrC_RM, n, m);

    return ptrC_RM;
    }

//float* matrixMultBest(float* ptrDevA, float* ptrDevB, float* ptrDevC, int m, int n, int k)
//    {
//    // Blas : apha A B + beta
//    float alpha = 1;
//    float beta = 0;
//
//    int ldA = k; // A mxk
//    int ldB = n; // B kxn
//    int ldC = n; // C mxn
//
//    // Cublas :  C_CM'=B_RM*A_RM=B_CM'*A_CM'
//    cublasHandle_t handle;
//    HANDLE_ERROR(cublasCreate(&handle));
//    HANDLE_ERROR(cublasSgemm(handle, CUBLAS_OP_N, CUBLAS_OP_N, n,m, k, &alpha, ptrDevB, ldB, ptrDevA, ldA, &beta, ptrDevC, ldC));// CUBLAS_OP_N => identity
//    HANDLE_ERROR(cublasDestroy(handle));
//
//    // Recuperation Resultat en CM
//    int dim = n * m; // CPrime_CM nxm
//    size_t sizeC = dim * sizeof(float);
//    float* ptrCPrime_CM = new float[dim];
//    HANDLE_ERROR(cudaMemcpy(ptrCPrime_CM, ptrDevC, sizeC, cudaMemcpyDeviceToHost));
//
//    // En sortie de cublas, on à C' en CM donc C en RM Verifions
//    float* ptrC_RM = ptrCPrime_CM;
//
//    afficher(ptrC_RM, m * n);
//    afficher(ptrC_RM, n, m);
//
//    return ptrC_RM;
//    }

/*------------------*\
 |*	Disons	    *|
 \*----------------*/

float* createA(int m, int k)
    {
    float* ptrA = new float[m * k];
    fillTab(ptrA, m, k);

    return ptrA;
    }

float* createB(int k, int n)
    {
    float* ptrB = new float[k, n];
    fillTab(ptrB, k, n);

    return ptrB;
    }

/*------------------*\
 |*	Generic	    *|
 \*----------------*/

unsigned int indice1D(int i, int j, int m)
    {
    return ((i - 1) * m) + j - 1;
    }

float* transpose(float* ptrTab, int n, int m)
    {
    float* ptrT = new float[n * m];
    for (int i = 1; i <= n; i++)
	{
	for (int j = 1; j <= m; j++)
	    {
	    // unsigned int s = indice1D(i, j, m);
	    unsigned int sT = indice1D(j, i, n);
	    ptrT[sT] = *ptrTab++;
	    }
	}
    return ptrT;
    }

void fillTab(float* ptrTab, int n, int m)
    {
    for (int i = 1; i <= n; i++)
	{
	for (int j = 1; j <= m; j++)
	    {
	    unsigned int s = indice1D(i, j, m);
//	    ptrTab[s] = s + 1;
	    *ptrTab++ = (s + 1);
	    }
	}
    }

void afficher(float* ptrTab, int n, int m)
    {
    cout << "\nMatrix : " << n << "x" << m << endl;
    for (int i = 1; i <= n; i++)
	{
	for (int j = 1; j <= m; j++)
	    {
//	    unsigned int s = indice1D(i, j, m);
//	    cout << ptrTab[s] << " ";
	    cout << *ptrTab++ << " ";
	    }
	cout << endl;
	}
    cout << endl;
    }

void afficher(float* ptrTab, int size)
    {
    cout << "\nVector : " << size << endl;
    for (int i = 1; i <= size; i++)
	{
	cout << *ptrTab++ << " ";
	}
    cout << endl;
    }

/*----------------------------------------------------------------------*\
 |*			End	 					*|
 \*---------------------------------------------------------------------*/

